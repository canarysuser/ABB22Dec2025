Multi-Threading in .NET 
- Threads are light-weight process 
- Allocated time slices by the OS 
- Threads created by the OS 
--> Thread Lifecycle
- New
- Ready  (Scheduled for execution) 
- Running
- Wait-Sleep-Join 
- Terminated
--> AbortRequested
	- Aborted

- System.Threading namespace 
- Thread class. 
-> represents the physical OS thread 
-> Physical thread is created when the logical .NET thread 
	starts 
--> allocates time slices 
-- Threads run in a perfectly chaotic manner 
-- Synchronization is required when multiple threads access shared resources
-- Thread can be foreground (default) or background 
- Threads executes a task (function) 
- Tasks or functions are assigned using ThreadStart or ParameterizedThreadStart delegate
- ThreadPriority can be set to influence the OS scheduler 
	- Lowest, BelowNormal, Normal, AboveNormal, Highest

Synchronization 
1. Object level sync
  - lock the object and sync access to it. 
  - Value type object are sync using Interlocked class 
  - Reference type objects are synced using Monitor class or the lock keyword
2. Process level sync
  - Mutex and Semaphore are used to sync across processes,
		sync access to critical section resources
  - named Mutex and Named Semaphore can be used to sync across processes
  - Mutex does not support concurrency, Semaphore supports controlled concurrency
3. ReaderWriterLockSlim
  - allows multiple readers or exclusive writer
  - improves performance when reads are more frequent than writes
4. CLR level sync 
 - [MethodImpl(MethodImplOptions.Synchronized)] attribute can be used to sync method access
 - locks the instance for instance methods and locks the type for static methods
5. Thread level Sync [ Producer-Consumer scenario ]
 - ResetEvent types in .NET [ AutoResetEvent - signalled multiple times, ManualResetEvent - signalled once ]


Task Parallel Programming
- Tasks are logical units of work
- Task is a higher level abstraction over threads
- Task thread pool manages the threads for executing tasks
- TPL and Data Parallelism are used for parallel programming
- Data Parallelism is achieved using Parallel class and PLINQ
	- from item in collection.AsParallel() select item
- Parallel class provides Parallel.For, Parallel.ForEach and Parallel.Invoke methods
- Task class provided by the System.Threading.Tasks namespace 
- Tasks can be created using Task.Run, Task.Factory.StartNew methods 
- Tasks can be chained using ContinueWith method
- Tasks are scheduled using TaskScheduler class
- Tasks can be waited using Task.WaitAll, Task.WaitAny methods
- Tasks can also be cancelled using CancellationToken
- Tasks are background by default, as it is pulled from the .NET ThreadPool 

Reflection 
- Run time type information 
- information about assemblies, modules, types, members 
- System.Reflection namespace
- System.Type class is the metaclass in .NET 
- allows to inspect types at runtime, query types, create instances dynamically, invoke methods dynamically
- Activator class is used to create instances dynamically
- System.Reflection.Emit namespace is used to create types dynamically at runtime
- MemberInfo is the base class for  MethodInfo, PropertyInfo, FieldInfo, EventInfo, ConstructorInfo classes

Managed Extensibility Framework (MEF)
- Used to create extensible applications
- Allows to discover and use extensions without configuration
- System.ComponentModel.Composition namespace
- Uses attributes to mark parts and their dependencies
- [Export] attribute to mark a class as a part
- [Import] attribute to mark a dependency on a part
- [ImportMany] attribute to mark a dependency on multiple parts
- CompositionContainer class to compose parts and satisfy dependencies
- Catalogs are used to discover parts (AssemblyCatalog, DirectoryCatalog)
- MEF supports both attributed programming model and convention based programming model
- MEF supports recomposition of parts at runtime

